/ Get the first input.
Input
store x

/ Get the second input
Input
store y

subt x

skipcond 800 / If y > x then loop x times.
	jump y_smaller

	load y
	store larger
	
	/ Set smaller to x
	load x
	store smaller
	
	/ Multiply x and y and store it as product. 
	mul_x_times, load x
	subt mulcounter

	skipcond 800 / When x-1 reached, stop multiplying.
		jump find_gcd

		load product
		add y
		store product
		/ Increment mulcounter
		load mulcounter
		add incrementer
		store mulcounter
		jump mul_x_times


/ If y is smaller of the two.
y_smaller, load x
store larger

load y
store smaller

mul_y_times, load y
subt mulcounter
	skipcond 800 / When y-1 reached, stop multiplying.
		jump find_gcd

		load product
		add x
		store product
		
		/ Increment mulcounter
		load mulcounter
		add incrementer
		store mulcounter
		jump mul_y_times


/ Finding the GCD of the numbers.
/ Divide both x and y from 1 to smaller.
find_gcd, load smaller
subt divisor

skipcond 800 / If divisor = smaller, stop and store the value of GCD.
	jump print_lcm

	/ divisor must start from 1, but better start from 2 since 1 is a universal divisor.
	load divisor
	add incrementer
	store divisor

	/ Divide the smaller number and check if exact division can happen.
	load smaller
	store p_smaller

	/ Continously subtracting divisor from number untill a value <0 is encountered.
	division_loop_gcd_for_smaller, load p_smaller
	subt divisor
	store p_smaller
	skipcond 800 / If p_smaller - divisor <= 0. then check for exact division.
		jump is_exact_divisor_of_smaller
		/ Go back to dividing.
		jump division_loop_gcd_for_smaller

	is_exact_divisor_of_smaller, skipcond 400 / Check exact division.
				jump find_gcd / If smaller % divisor != 0, then go to the next divisor.
			
				/ If the divisor is able to exactly divide smaller, look if it can exactly divide the larger value.
				/ If it can, then store it as the gcd.
				load larger
				store p_larger

				/ Continously subtracting divisor from number untill a value <0 is encountered.
				division_loop_gcd_for_larger, load p_larger
				subt divisor
				store p_larger
				skipcond 800 / If p_larger - divisor <= 0. then check for exact division.
					jump is_exact_divisor_of_larger
					/ Go back to dividing.
					jump division_loop_gcd_for_larger

	is_exact_divisor_of_larger, skipcond 400 / If it's an exact divisor of larger too, then update current divisor as the gcd.
							jump find_gcd / If larger % divisor != 0, proceed with the next divisor.

							load divisor
							store gcd
							jump find_gcd


print_lcm, load product
/ (product/gcd) = lcm.
/ Basic Integer division - Only handles positive fractions properly.
/ Handling exact division.
store p_product

/ GCD is never 0 for any two non-zero positive integers.

/ Perform (product/gcd)
/ Continously subtracting gcd from product untill a value <0 is encountered.
loop, load p_product
subt gcd
store p_product

skipcond 800 / If p_product - gcd <= 0. then check for exact division.
	jump has_lcm
	
	/ Increment quotient(lcm) by 1.
	load lcm
	add incrementer
	store lcm
	
	/ Go back to dividing.
	jump loop

has_lcm, skipcond 400 / Check exact division.
			jump no_lcm

			load lcm
			add incrementer
			Output
			Halt
			
no_lcm,Halt


x, dec 0
y, dec 0
initializer, dec 0
incrementer, dec 1


product, dec 0
p_product, dec 0 / Not required if it's ok to lose original value of product.
mulcounter, dec 0

smaller, dec 0
p_smaller, dec 0
larger, dec 0
p_larger, dec 0
divisor, dec 1 / Variable to find the GCD of the two numbers. Goes from 1 to the value lesser between x and y.

lcm, dec 0
gcd, dec 1
